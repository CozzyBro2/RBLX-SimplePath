{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"SimplePath is an open-source pathfinding module that gives you the ability to quickly create a pathfinding script for humanoids and non-humanoids with just a few lines of code. Pathfinding is done using Roblox's PathfindingService . This module works by using a \"repetitive\" approach to pathfinding. The pathfinding agent moves a more efficient path when computed repetitively instead of just once. Part of the reason why is because computing the path once doesn't guarantee that the agent reaches the goal as expected. Taking the repetitive approach accounts for any obstructions or obstacles blocking the path at the current time. This guarantees that the agent will reach its goal no matter what as long as it's traversable within the scope of PathfindingService. Although you can still use SimplePath normally, it is strongly suggested that you take a repetitive approach to pathfinding as this was the primary concept kept in mind during the development of this module. However, in some scenarios, it might be better to compute the path just once. For example, if the agent does not interact with moving objects, you should consider changing the structure of your pathfinding code by reducing the number of repetitions between path computations to improve performance. To get started with using SimplePath visit Getting Started . Installation: Get the SimplePath modulescript from Roblox or get the latest release from GitHub. Links: GitHub DevForum Roblox Discord","title":"Home"},{"location":"api-reference/","text":"Configuration \u00b6 The settings below are default values that can be accessed directly from the SimplePath modulescript. Note Changing default settings will only affect agents that don't already have overridden settings. To override settings for a single agent, pass in a dictionary (with a setting as the key) to the constructor and include values in the dictionary to override. See constructor for more info. TIME_VARIANCE \u00b6 Settings.TIME_VARIANCE: number [default: 0.07] Represents the minimum time in seconds elapsed between Path.Run calls. The default setting is roughly 14 computations per second. This is necessary to allow the agent the freedom for movement (give the agent some time to reach the next waypoint before computing a new path). COMPARISON_CHECKS \u00b6 Settings.COMPARISON_CHECKS: number [default: 1] During pathfinding, in the case where the agent is stationary at the same position for 1 + COMPARISON_CHECKS consecutive Path.Run calls, the agent attempts to avoid the obstruction by jumping. This is necessary in order to prevent the agent from being at rest for infinity (unless otherwise moved by an external object). JUMP_WHEN_STUCK \u00b6 Settings.JUMP_WHEN_STUCK: boolean [default: true] [humanoid only] Settings.JUMP_WHEN_STUCK is directly dependant on Settings.COMPARISON_CHECKS . If this is false, the agent will not attempt to jump. Warning Overriding this setting to false will prevent the agent from jumping which can cause the agent to remain at rest for infinity. Do not disable this setting without properly handling it using ErrorType.AgentStuck . ErrorTypes \u00b6 Example 1 2 3 4 5 Path . Error : Connect ( function ( errorType ) if errorType == SimplePath . ErrorType . ComputationError then --code (1) end end ) This code block will run whenever there's a ComputationError. Info Use ErrorTypes to determine the type of error received from the Path.Error event. For additional debug options, see Path.LastError . LimitReached \u00b6 ErrorType.LimitReached: ErrorType and string The elapsed time between Path.Run calls is less than Settings.TIME_VARIANCE. For stability purposes, this error is invoked after Path:Run() yields for Settings.TIME_VARIANCE. It is recommended to avoid depending on this ErrorType. TargetUnreachable \u00b6 ErrorType.TargetUnreachable: ErrorType and string Target is unreachable. ComputationError \u00b6 ErrorType.ComputationError: ErrorType and string Path computation failed. AgentStuck \u00b6 ErrorType.AgentStuck: ErrorType and string Agent is stuck (possibly due to an obstruction of some kind). Note This is different from Path.Blocked in the sense that it is detected by SimplePath itself when the agent does not move for Settings.COMPARISON_CHECKS + 1 consecutive Path.Run calls. StatusTypes \u00b6 Read the Path.Status property to get the current Path status. Idle \u00b6 StatusType.Idle: StatusType and string Path is in idle state. Active \u00b6 StatusType.Active: StatusType and string Path is in active state. Static Methods \u00b6 GetNearestCharacter \u00b6 <model or nil> SimplePath.GetNearestCharacter(fromPosition: Vector3) Returns a model of the nearest character from the provided Vector3 position or nil if no character is found. Path \u00b6 Constructor \u00b6 <Path> SimplePath.new(agent: model, agentParameters: Dictionary or nil, override: Dictionary or nil) Creates a new Path object using the agent with optional agentParameters . Pass in override as a dictionary that includes a setting and its overridden value. Note SimplePath.new() is a constructor that creates a new Path and it should only be created once per agent. You can call Path:Run() on the same Path object multiple times without having to create a new Path every time you need to do pathfinding. Info Use agent parameters for custom characters to compute the best path. Find out more about agent parameters and how to use them at Roblox Developer Hub . Refine the path computation further by using pathfinding modifiers. To use this feature with SimplePath, Simply include modifier data in agentParameters normally. Find out more about pathfinding modifiers at Roblox Developer Hub . Properties \u00b6 Visualize \u00b6 Path.Visualize: boolean [default: false] Set this property to true before the first Path:Run() to visualize waypoints. Status \u00b6 Path.Status: SimplePath.StatusType [readonly] Returns the current StatusType of Path. Note This will return SimplePath.StatusType.Idle always for non-humanoids since pathfinding for a non-humanoid is meant to be handled manually. LastError \u00b6 Path.LastError: SimplePath.ErrorType [readonly] Returns the last ErrorType . Methods \u00b6 Run \u00b6 <boolean> Path:Run(target: Vector3 or BasePart) This method returns true if the computation was successful. If it returns false , the Path.Error event is fired with a ComputationError. This method automatically yields if the elapsed time between consecutive calls is less than Settings.TIME_VARIANCE. Stop \u00b6 <void> Path:Stop() Stops the navigation of the current Path if Path.Status is in an active state and fires the Path.Stopped event. Note This method cannot be used for non-humanoids since pathfinding is meant to be handled manually. Destroy \u00b6 <void> Path:Destroy() Destroy Path. Events \u00b6 Reached \u00b6 <RBXScriptSignal> Path.Reached(agent: model, finalWaypoint: PathWaypoint) This event is fired after the agent reaches its target and returns the final PathWaypoint . Info Find out more about PathWaypoint at Roblox Developer Hub . WaypointReached \u00b6 <RBXScriptSignal> Path.WaypointReached(agent: model, last: PathWaypoint, next: PathWaypoint) This event is fired every time the next PathWaypoint is reached. Note Make use of this event when pathfinding for non-humanoids. Warning For stabililty purposes, this event will not fire for the second-last waypoint when used for Humanoids. Blocked \u00b6 <RBXScriptSignal> Path.Blocked(agent: model, blocked: PathWaypoint) blocked is a PathWaypoint such that: currentWaypoint.Index <= blocked.Index <= currentWaypoint.Index + 1 . Error \u00b6 <RBXScriptSignal> Path.Error(error: ErrorType and string) Fires when an error from any of the ErrorTypes occurs. Stopped \u00b6 <RBXScriptSignal> Path.Stopped(agent: model) Fires after Path:Stop() is called. Note Just like the Path.Stop method, this event should only be used for humanoids.","title":"API Reference"},{"location":"api-reference/#configuration","text":"The settings below are default values that can be accessed directly from the SimplePath modulescript. Note Changing default settings will only affect agents that don't already have overridden settings. To override settings for a single agent, pass in a dictionary (with a setting as the key) to the constructor and include values in the dictionary to override. See constructor for more info.","title":"Configuration"},{"location":"api-reference/#time_variance","text":"Settings.TIME_VARIANCE: number [default: 0.07] Represents the minimum time in seconds elapsed between Path.Run calls. The default setting is roughly 14 computations per second. This is necessary to allow the agent the freedom for movement (give the agent some time to reach the next waypoint before computing a new path).","title":"TIME_VARIANCE"},{"location":"api-reference/#comparison_checks","text":"Settings.COMPARISON_CHECKS: number [default: 1] During pathfinding, in the case where the agent is stationary at the same position for 1 + COMPARISON_CHECKS consecutive Path.Run calls, the agent attempts to avoid the obstruction by jumping. This is necessary in order to prevent the agent from being at rest for infinity (unless otherwise moved by an external object).","title":"COMPARISON_CHECKS"},{"location":"api-reference/#jump_when_stuck","text":"Settings.JUMP_WHEN_STUCK: boolean [default: true] [humanoid only] Settings.JUMP_WHEN_STUCK is directly dependant on Settings.COMPARISON_CHECKS . If this is false, the agent will not attempt to jump. Warning Overriding this setting to false will prevent the agent from jumping which can cause the agent to remain at rest for infinity. Do not disable this setting without properly handling it using ErrorType.AgentStuck .","title":"JUMP_WHEN_STUCK"},{"location":"api-reference/#errortypes","text":"Example 1 2 3 4 5 Path . Error : Connect ( function ( errorType ) if errorType == SimplePath . ErrorType . ComputationError then --code (1) end end ) This code block will run whenever there's a ComputationError. Info Use ErrorTypes to determine the type of error received from the Path.Error event. For additional debug options, see Path.LastError .","title":"ErrorTypes"},{"location":"api-reference/#limitreached","text":"ErrorType.LimitReached: ErrorType and string The elapsed time between Path.Run calls is less than Settings.TIME_VARIANCE. For stability purposes, this error is invoked after Path:Run() yields for Settings.TIME_VARIANCE. It is recommended to avoid depending on this ErrorType.","title":"LimitReached"},{"location":"api-reference/#targetunreachable","text":"ErrorType.TargetUnreachable: ErrorType and string Target is unreachable.","title":"TargetUnreachable"},{"location":"api-reference/#computationerror","text":"ErrorType.ComputationError: ErrorType and string Path computation failed.","title":"ComputationError"},{"location":"api-reference/#agentstuck","text":"ErrorType.AgentStuck: ErrorType and string Agent is stuck (possibly due to an obstruction of some kind). Note This is different from Path.Blocked in the sense that it is detected by SimplePath itself when the agent does not move for Settings.COMPARISON_CHECKS + 1 consecutive Path.Run calls.","title":"AgentStuck"},{"location":"api-reference/#statustypes","text":"Read the Path.Status property to get the current Path status.","title":"StatusTypes"},{"location":"api-reference/#idle","text":"StatusType.Idle: StatusType and string Path is in idle state.","title":"Idle"},{"location":"api-reference/#active","text":"StatusType.Active: StatusType and string Path is in active state.","title":"Active"},{"location":"api-reference/#static-methods","text":"","title":"Static Methods"},{"location":"api-reference/#getnearestcharacter","text":"<model or nil> SimplePath.GetNearestCharacter(fromPosition: Vector3) Returns a model of the nearest character from the provided Vector3 position or nil if no character is found.","title":"GetNearestCharacter"},{"location":"api-reference/#path","text":"","title":"Path"},{"location":"api-reference/#constructor","text":"<Path> SimplePath.new(agent: model, agentParameters: Dictionary or nil, override: Dictionary or nil) Creates a new Path object using the agent with optional agentParameters . Pass in override as a dictionary that includes a setting and its overridden value. Note SimplePath.new() is a constructor that creates a new Path and it should only be created once per agent. You can call Path:Run() on the same Path object multiple times without having to create a new Path every time you need to do pathfinding. Info Use agent parameters for custom characters to compute the best path. Find out more about agent parameters and how to use them at Roblox Developer Hub . Refine the path computation further by using pathfinding modifiers. To use this feature with SimplePath, Simply include modifier data in agentParameters normally. Find out more about pathfinding modifiers at Roblox Developer Hub .","title":"Constructor"},{"location":"api-reference/#properties","text":"","title":"Properties"},{"location":"api-reference/#visualize","text":"Path.Visualize: boolean [default: false] Set this property to true before the first Path:Run() to visualize waypoints.","title":"Visualize"},{"location":"api-reference/#status","text":"Path.Status: SimplePath.StatusType [readonly] Returns the current StatusType of Path. Note This will return SimplePath.StatusType.Idle always for non-humanoids since pathfinding for a non-humanoid is meant to be handled manually.","title":"Status"},{"location":"api-reference/#lasterror","text":"Path.LastError: SimplePath.ErrorType [readonly] Returns the last ErrorType .","title":"LastError"},{"location":"api-reference/#methods","text":"","title":"Methods"},{"location":"api-reference/#run","text":"<boolean> Path:Run(target: Vector3 or BasePart) This method returns true if the computation was successful. If it returns false , the Path.Error event is fired with a ComputationError. This method automatically yields if the elapsed time between consecutive calls is less than Settings.TIME_VARIANCE.","title":"Run"},{"location":"api-reference/#stop","text":"<void> Path:Stop() Stops the navigation of the current Path if Path.Status is in an active state and fires the Path.Stopped event. Note This method cannot be used for non-humanoids since pathfinding is meant to be handled manually.","title":"Stop"},{"location":"api-reference/#destroy","text":"<void> Path:Destroy() Destroy Path.","title":"Destroy"},{"location":"api-reference/#events","text":"","title":"Events"},{"location":"api-reference/#reached","text":"<RBXScriptSignal> Path.Reached(agent: model, finalWaypoint: PathWaypoint) This event is fired after the agent reaches its target and returns the final PathWaypoint . Info Find out more about PathWaypoint at Roblox Developer Hub .","title":"Reached"},{"location":"api-reference/#waypointreached","text":"<RBXScriptSignal> Path.WaypointReached(agent: model, last: PathWaypoint, next: PathWaypoint) This event is fired every time the next PathWaypoint is reached. Note Make use of this event when pathfinding for non-humanoids. Warning For stabililty purposes, this event will not fire for the second-last waypoint when used for Humanoids.","title":"WaypointReached"},{"location":"api-reference/#blocked","text":"<RBXScriptSignal> Path.Blocked(agent: model, blocked: PathWaypoint) blocked is a PathWaypoint such that: currentWaypoint.Index <= blocked.Index <= currentWaypoint.Index + 1 .","title":"Blocked"},{"location":"api-reference/#error","text":"<RBXScriptSignal> Path.Error(error: ErrorType and string) Fires when an error from any of the ErrorTypes occurs.","title":"Error"},{"location":"api-reference/#stopped","text":"<RBXScriptSignal> Path.Stopped(agent: model) Fires after Path:Stop() is called. Note Just like the Path.Stop method, this event should only be used for humanoids.","title":"Stopped"},{"location":"examples/humanoid/","text":"Humanoid Examples \u00b6 The following examples is explained in detail here . Using Events \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 --Import the module so you can start using it local ServerStorage = game : GetService ( \"ServerStorage\" ) local SimplePath = require ( ServerStorage . SimplePath ) --Define npc local Dummy = workspace . Dummy -- Define a part called \"Goal\" local Goal = workspace . Goal --Create a new Path using the Dummy local Path = SimplePath . new ( Dummy ) --Helps to visualize the path Path . Visualize = true --Compute a new path every time the Dummy reaches the goal part Path . Reached : Connect ( function () Path : Run ( Goal ) end ) --Dummy knows to compute path again if something blocks the path Path . Blocked : Connect ( function () Path : Run ( Goal ) end ) --If the position of Goal changes at the next waypoint, compute path again Path . WaypointReached : Connect ( function () Path : Run ( Goal ) end ) --Dummmy knows to compute path again if an error occurs Path . Error : Connect ( function ( errorType ) Path : Run ( Goal ) end ) Path : Run ( Goal ) Using Loops \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 --Import the module so you can start using it local ServerStorage = game : GetService ( \"ServerStorage\" ) local SimplePath = require ( ServerStorage . SimplePath ) --Define npc local Dummy = workspace . Dummy -- Define a part called \"Goal\" local Goal = workspace . Goal --Create a new Path using the Dummy local Path = SimplePath . new ( Dummy ) --Helps to visualize the path Path . Visualize = true while true do Path : Run ( Goal ) end","title":"Humanoid"},{"location":"examples/humanoid/#humanoid-examples","text":"The following examples is explained in detail here .","title":"Humanoid Examples"},{"location":"examples/humanoid/#using-events","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 --Import the module so you can start using it local ServerStorage = game : GetService ( \"ServerStorage\" ) local SimplePath = require ( ServerStorage . SimplePath ) --Define npc local Dummy = workspace . Dummy -- Define a part called \"Goal\" local Goal = workspace . Goal --Create a new Path using the Dummy local Path = SimplePath . new ( Dummy ) --Helps to visualize the path Path . Visualize = true --Compute a new path every time the Dummy reaches the goal part Path . Reached : Connect ( function () Path : Run ( Goal ) end ) --Dummy knows to compute path again if something blocks the path Path . Blocked : Connect ( function () Path : Run ( Goal ) end ) --If the position of Goal changes at the next waypoint, compute path again Path . WaypointReached : Connect ( function () Path : Run ( Goal ) end ) --Dummmy knows to compute path again if an error occurs Path . Error : Connect ( function ( errorType ) Path : Run ( Goal ) end ) Path : Run ( Goal )","title":"Using Events"},{"location":"examples/humanoid/#using-loops","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 --Import the module so you can start using it local ServerStorage = game : GetService ( \"ServerStorage\" ) local SimplePath = require ( ServerStorage . SimplePath ) --Define npc local Dummy = workspace . Dummy -- Define a part called \"Goal\" local Goal = workspace . Goal --Create a new Path using the Dummy local Path = SimplePath . new ( Dummy ) --Helps to visualize the path Path . Visualize = true while true do Path : Run ( Goal ) end","title":"Using Loops"},{"location":"examples/non-humanoid/","text":"Non-Humanoid Examples \u00b6 Pathfinding for non-humanoid models can get a little complicated. Consider converting your non-humanoid model to a humanoid if possible. Example 1 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 local TweenService = game : GetService ( \"TweenService\" ) local ServerStorage = game : GetService ( \"ServerStorage\" ) local SimplePath = require ( ServerStorage . SimplePath ) local Model = workspace . Model local Goal = workspace . Goal local Path = SimplePath . new ( Model ) local function tween ( part , destination ) local tweenBase = TweenService : Create ( part , TweenInfo . new ( 0.07 ), { Position = destination + Vector3 . new ( 0 , 0.5 , 0 )}) tweenBase : Play () tweenBase . Completed : Wait () end Path . Visualize = true --Tween model to final waypoint when reached Path . Reached : Connect ( function ( model , finalWaypoint ) tween ( model . PrimaryPart , finalWaypoint . Position ) end ) --Call Path:Run() at the end of the event to indicate the end of movement for the current waypoint Path . WaypointReached : Connect ( function ( model , lastWaypoint , nextWaypoint ) tween ( model . PrimaryPart , nextWaypoint . Position ) Path : Run () end ) Path : Run ( Goal ) Example 2 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 local TweenService = game : GetService ( \"TweenService\" ) local ServerStorage = game : GetService ( \"ServerStorage\" ) local SimplePath = require ( ServerStorage . SimplePath ) local Model = workspace . Model local Goal = workspace . Goal local Path = SimplePath . new ( Model ) local function tween ( part , destination ) local tweenBase = TweenService : Create ( part , TweenInfo . new ( 0.07 ), { Position = destination + Vector3 . new ( 0 , 0.5 , 0 )}) tweenBase : Play () tweenBase . Completed : Wait () end Path . Visualize = true --If the path is blocked Path . Blocked : Connect ( function () Path : Run ( Goal ) end ) --In case of an error Path . Error : Connect ( function () Path : Run ( Goal ) end ) Path . Reached : Connect ( function ( model , finalWaypoint ) tween ( model . PrimaryPart , finalWaypoint . Position ) Path : Run ( Goal ) end ) Path . WaypointReached : Connect ( function ( model , lastWaypoint , nextWaypoint ) tween ( model . PrimaryPart , nextWaypoint . Position ) Path : Run ( Goal ) end ) Path : Run ( Goal ) Example 3 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 local TweenService = game : GetService ( \"TweenService\" ) local ServerStorage = game : GetService ( \"ServerStorage\" ) local SimplePath = require ( ServerStorage . SimplePath ) local Model = workspace . Model local Goal = workspace . Goal local Path = SimplePath . new ( Model ) Path . Visualize = true Path . Reached : Connect ( function ( model , finalWaypoint ) model . PrimaryPart . Position = finalWaypoint . Position + Vector3 . new ( 0 , 0.5 , 1 ) end ) Path . WaypointReached : Connect ( function ( model , lastWaypoint , nextWaypoint ) model . PrimaryPart . Position = nextWaypoint . Position + Vector3 . new ( 0 , 0.5 , 1 ) end ) while true do Path : Run ( Goal ) task . wait () end","title":"Non-Humanoid"},{"location":"examples/non-humanoid/#non-humanoid-examples","text":"Pathfinding for non-humanoid models can get a little complicated. Consider converting your non-humanoid model to a humanoid if possible.","title":"Non-Humanoid Examples"},{"location":"examples/non-humanoid/#example-1","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 local TweenService = game : GetService ( \"TweenService\" ) local ServerStorage = game : GetService ( \"ServerStorage\" ) local SimplePath = require ( ServerStorage . SimplePath ) local Model = workspace . Model local Goal = workspace . Goal local Path = SimplePath . new ( Model ) local function tween ( part , destination ) local tweenBase = TweenService : Create ( part , TweenInfo . new ( 0.07 ), { Position = destination + Vector3 . new ( 0 , 0.5 , 0 )}) tweenBase : Play () tweenBase . Completed : Wait () end Path . Visualize = true --Tween model to final waypoint when reached Path . Reached : Connect ( function ( model , finalWaypoint ) tween ( model . PrimaryPart , finalWaypoint . Position ) end ) --Call Path:Run() at the end of the event to indicate the end of movement for the current waypoint Path . WaypointReached : Connect ( function ( model , lastWaypoint , nextWaypoint ) tween ( model . PrimaryPart , nextWaypoint . Position ) Path : Run () end ) Path : Run ( Goal )","title":"Example 1"},{"location":"examples/non-humanoid/#example-2","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 local TweenService = game : GetService ( \"TweenService\" ) local ServerStorage = game : GetService ( \"ServerStorage\" ) local SimplePath = require ( ServerStorage . SimplePath ) local Model = workspace . Model local Goal = workspace . Goal local Path = SimplePath . new ( Model ) local function tween ( part , destination ) local tweenBase = TweenService : Create ( part , TweenInfo . new ( 0.07 ), { Position = destination + Vector3 . new ( 0 , 0.5 , 0 )}) tweenBase : Play () tweenBase . Completed : Wait () end Path . Visualize = true --If the path is blocked Path . Blocked : Connect ( function () Path : Run ( Goal ) end ) --In case of an error Path . Error : Connect ( function () Path : Run ( Goal ) end ) Path . Reached : Connect ( function ( model , finalWaypoint ) tween ( model . PrimaryPart , finalWaypoint . Position ) Path : Run ( Goal ) end ) Path . WaypointReached : Connect ( function ( model , lastWaypoint , nextWaypoint ) tween ( model . PrimaryPart , nextWaypoint . Position ) Path : Run ( Goal ) end ) Path : Run ( Goal )","title":"Example 2"},{"location":"examples/non-humanoid/#example-3","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 local TweenService = game : GetService ( \"TweenService\" ) local ServerStorage = game : GetService ( \"ServerStorage\" ) local SimplePath = require ( ServerStorage . SimplePath ) local Model = workspace . Model local Goal = workspace . Goal local Path = SimplePath . new ( Model ) Path . Visualize = true Path . Reached : Connect ( function ( model , finalWaypoint ) model . PrimaryPart . Position = finalWaypoint . Position + Vector3 . new ( 0 , 0.5 , 1 ) end ) Path . WaypointReached : Connect ( function ( model , lastWaypoint , nextWaypoint ) model . PrimaryPart . Position = nextWaypoint . Position + Vector3 . new ( 0 , 0.5 , 1 ) end ) while true do Path : Run ( Goal ) task . wait () end","title":"Example 3"},{"location":"guides/getting-started/","text":"This tutorial shows you how you can set up SimplePath and teaches you a basic implementation of the module. Installation \u00b6 Get the module from the Roblox library or get the latest release from GitHub. Note For the purposes of the tutorial, the script assumes the modulescript is in game.ServerStorage . After you insert the module to your place, add a new script to game.ServerScriptService and paste the folowing code to start using the module: --Import the module so you can start using it local ServerStorage = game : GetService ( \"ServerStorage\" ) local SimplePath = require ( ServerStorage . SimplePath ) The next part of the code defines all of the different variables that will be used in the script: --Define npc local Dummy = workspace . Dummy --Define a part called \"Goal\" local Goal = workspace . Goal --Create a new Path using the Dummy local Path = SimplePath . new ( Dummy ) Note SimplePath.new() is a constructor that creates a new Path and it should only be created once per agent. You can call Path:Run() on the same Path object multiple times without having to create a new Path every time you need to do pathfinding. Method 1: Using Events \u00b6 The following part of the tutorial shows you how you can make a pathfinding script using only events. To make the Dummy move towards the goal, you only need one line of code: Path : Run ( Goal ) Even though this single line of code seems sufficient, there are a few important things to keep in mind. Firstly, if some object comes in-between the path of the Dummy, the Dummy will just stop pathfinding before reaching the goal because Path:Run() is not called a second time to compute the path again. To fix this, you can use the Path.Blocked event and call Path:Run() whenever something blocks the path: --Dummy knows to compute path again if something blocks the path Path . Blocked : Connect ( function () Path : Run ( Goal ) end ) The next thing to keep in mind is the position of the goal part. In the case where the goal part is constantly moving, how can you alter the current path of Dummy to make sure that it reaches the exact position of the goal part? You can do this by adding in 2 more events. The Path.WaypointReached event will compute a new Path everytime the Dummy reaches the next waypoint and accounts for a new position of the goal part if it changed. --If the position of Goal changes at the next waypoint, compute path again Path . WaypointReached : Connect ( function () Path : Run ( Goal ) end ) The second event is Path.Error . You can compute a new path every time the target becomes unreachable or the path to the goal is not traversable. For example, if the part is floating in the sky, the Dummy would not be able to reach it and Path.Error fires. --Dummmy knows to compute path again if an error occurs Path . Error : Connect ( function ( errorType ) Path : Run ( Goal ) end ) Your code should look something like this after adding everything in: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 --Import the module so you can start using it local ServerStorage = game : GetService ( \"ServerStorage\" ) local SimplePath = require ( ServerStorage . SimplePath ) --Define npc local Dummy = workspace . Dummy -- Define a part called \"Goal\" local Goal = workspace . Goal --Create a new Path using the Dummy local Path = SimplePath . new ( Dummy ) --Helps to visualize the path Path . Visualize = true --Dummy knows to compute path again if something blocks the path Path . Blocked : Connect ( function () Path : Run ( Goal ) end ) --If the position of Goal changes at the next waypoint, compute path again Path . WaypointReached : Connect ( function () Path : Run ( Goal ) end ) --Dummmy knows to compute path again if an error occurs Path . Error : Connect ( function ( errorType ) Path : Run ( Goal ) end ) Path : Run ( Goal ) Info Set Path.Visualize to true before the very first Path:Run() call to see the waypoints. As you can see, the Dummy stops pathfinding after reaching the goal. If you want the Dummy to always follow the goal part even after reaching it, you can simply use the Path.Reached event: --Compute a new path every time the Dummy reaches the goal part Path . Reached : Connect ( function () Path : Run ( Goal ) end ) Method 2: Using Loops \u00b6 In the following tutorial, you will learn how to use SimplePath using loops instead of events. Using SimplePath in a loop is way simpler than using events. You only need 3 lines of code: while true do Path : Run ( Goal ) end Path:Run() does not require a wait because it automatically yields if the maximum time elapsed between consecutive calls are less than Settings.TIME_VARIANCE . If you are using loops, your final code should look something like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 --Import the module so you can start using it local ServerStorage = game : GetService ( \"ServerStorage\" ) local SimplePath = require ( ServerStorage . SimplePath ) --Define npc local Dummy = workspace . Dummy -- Define a part called \"Goal\" local Goal = workspace . Goal --Create a new Path using the Dummy local Path = SimplePath . new ( Dummy ) --Helps to visualize the path Path . Visualize = true while true do Path : Run ( Goal ) end Choosing the right method \u00b6 SimplePath gives you the freedom to code in any method you prefer. You are not limited to the two methods mentioned in this tutorial as they are simply meant to be examples. You can even combine both methods and implement them together at once. It all depends on how you decide to structure your code based on the performance, compatibility, etc. and personal preference.","title":"Getting Started"},{"location":"guides/getting-started/#installation","text":"Get the module from the Roblox library or get the latest release from GitHub. Note For the purposes of the tutorial, the script assumes the modulescript is in game.ServerStorage . After you insert the module to your place, add a new script to game.ServerScriptService and paste the folowing code to start using the module: --Import the module so you can start using it local ServerStorage = game : GetService ( \"ServerStorage\" ) local SimplePath = require ( ServerStorage . SimplePath ) The next part of the code defines all of the different variables that will be used in the script: --Define npc local Dummy = workspace . Dummy --Define a part called \"Goal\" local Goal = workspace . Goal --Create a new Path using the Dummy local Path = SimplePath . new ( Dummy ) Note SimplePath.new() is a constructor that creates a new Path and it should only be created once per agent. You can call Path:Run() on the same Path object multiple times without having to create a new Path every time you need to do pathfinding.","title":"Installation"},{"location":"guides/getting-started/#method-1-using-events","text":"The following part of the tutorial shows you how you can make a pathfinding script using only events. To make the Dummy move towards the goal, you only need one line of code: Path : Run ( Goal ) Even though this single line of code seems sufficient, there are a few important things to keep in mind. Firstly, if some object comes in-between the path of the Dummy, the Dummy will just stop pathfinding before reaching the goal because Path:Run() is not called a second time to compute the path again. To fix this, you can use the Path.Blocked event and call Path:Run() whenever something blocks the path: --Dummy knows to compute path again if something blocks the path Path . Blocked : Connect ( function () Path : Run ( Goal ) end ) The next thing to keep in mind is the position of the goal part. In the case where the goal part is constantly moving, how can you alter the current path of Dummy to make sure that it reaches the exact position of the goal part? You can do this by adding in 2 more events. The Path.WaypointReached event will compute a new Path everytime the Dummy reaches the next waypoint and accounts for a new position of the goal part if it changed. --If the position of Goal changes at the next waypoint, compute path again Path . WaypointReached : Connect ( function () Path : Run ( Goal ) end ) The second event is Path.Error . You can compute a new path every time the target becomes unreachable or the path to the goal is not traversable. For example, if the part is floating in the sky, the Dummy would not be able to reach it and Path.Error fires. --Dummmy knows to compute path again if an error occurs Path . Error : Connect ( function ( errorType ) Path : Run ( Goal ) end ) Your code should look something like this after adding everything in: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 --Import the module so you can start using it local ServerStorage = game : GetService ( \"ServerStorage\" ) local SimplePath = require ( ServerStorage . SimplePath ) --Define npc local Dummy = workspace . Dummy -- Define a part called \"Goal\" local Goal = workspace . Goal --Create a new Path using the Dummy local Path = SimplePath . new ( Dummy ) --Helps to visualize the path Path . Visualize = true --Dummy knows to compute path again if something blocks the path Path . Blocked : Connect ( function () Path : Run ( Goal ) end ) --If the position of Goal changes at the next waypoint, compute path again Path . WaypointReached : Connect ( function () Path : Run ( Goal ) end ) --Dummmy knows to compute path again if an error occurs Path . Error : Connect ( function ( errorType ) Path : Run ( Goal ) end ) Path : Run ( Goal ) Info Set Path.Visualize to true before the very first Path:Run() call to see the waypoints. As you can see, the Dummy stops pathfinding after reaching the goal. If you want the Dummy to always follow the goal part even after reaching it, you can simply use the Path.Reached event: --Compute a new path every time the Dummy reaches the goal part Path . Reached : Connect ( function () Path : Run ( Goal ) end )","title":"Method 1: Using Events"},{"location":"guides/getting-started/#method-2-using-loops","text":"In the following tutorial, you will learn how to use SimplePath using loops instead of events. Using SimplePath in a loop is way simpler than using events. You only need 3 lines of code: while true do Path : Run ( Goal ) end Path:Run() does not require a wait because it automatically yields if the maximum time elapsed between consecutive calls are less than Settings.TIME_VARIANCE . If you are using loops, your final code should look something like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 --Import the module so you can start using it local ServerStorage = game : GetService ( \"ServerStorage\" ) local SimplePath = require ( ServerStorage . SimplePath ) --Define npc local Dummy = workspace . Dummy -- Define a part called \"Goal\" local Goal = workspace . Goal --Create a new Path using the Dummy local Path = SimplePath . new ( Dummy ) --Helps to visualize the path Path . Visualize = true while true do Path : Run ( Goal ) end","title":"Method 2: Using Loops"},{"location":"guides/getting-started/#choosing-the-right-method","text":"SimplePath gives you the freedom to code in any method you prefer. You are not limited to the two methods mentioned in this tutorial as they are simply meant to be examples. You can even combine both methods and implement them together at once. It all depends on how you decide to structure your code based on the performance, compatibility, etc. and personal preference.","title":"Choosing the right method"}]}